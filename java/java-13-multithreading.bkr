{
    "beaker": "2",
    "evaluators": [
        {
            "name": "HTML",
            "plugin": "HTML",
            "view": {
                "cm": {
                    "mode": "htmlmixed"
                }
            }
        },
        {
            "name": "JavaScript",
            "plugin": "JavaScript",
            "view": {
                "cm": {
                    "mode": "javascript",
                    "background": "#FFE0F0"
                }
            },
            "languageVersion": "ES2015"
        },
        {
            "name": "Java",
            "plugin": "Java",
            "imports": "com.twosigma.beaker.chart.Color\ncom.twosigma.beaker.chart.GradientColor\ncom.twosigma.beaker.chart.legend.*\ncom.twosigma.beaker.chart.Filter\ncom.twosigma.beaker.BeakerProgressUpdate\ncom.twosigma.beaker.chart.xychart.*\ncom.twosigma.beaker.chart.xychart.plotitem.*\ncom.twosigma.beaker.chart.categoryplot.*\ncom.twosigma.beaker.chart.categoryplot.plotitem.*\ncom.twosigma.beaker.chart.histogram.*\ncom.twosigma.beaker.chart.treemap.*\ncom.twosigma.beaker.chart.treemap.util.*\nnet.sf.jtreemap.swing.*\ncom.twosigma.beaker.NamespaceClient\ncom.twosigma.beaker.chart.heatmap.HeatMap\ncom.twosigma.beaker.jvm.object.*\ncom.twosigma.beaker.easyform.*\ncom.twosigma.beaker.easyform.formitem.*",
            "view": {
                "cm": {
                    "mode": "text/x-java"
                }
            }
        }
    ],
    "cells": [
        {
            "id": "markdownyIL3Xh",
            "type": "markdown",
            "body": [
                "# Multithreading"
            ],
            "evaluatorReader": false
        },
        {
            "id": "sectiona4kEFF",
            "type": "section",
            "title": "Running Threads",
            "level": 1,
            "evaluatorReader": false,
            "collapsed": true
        },
        {
            "id": "markdownj8FgDo",
            "type": "markdown",
            "body": [
                "A **thread** is a program unit that is executed _independently_ of other parts of the program."
            ],
            "evaluatorReader": false
        },
        {
            "id": "markdownL6gG0m",
            "type": "markdown",
            "body": [
                "## Running a thread is simple in Java -- follow these stpes:"
            ],
            "evaluatorReader": false
        },
        {
            "id": "sectionDFXoUH",
            "type": "section",
            "title": "Step 0: Runnable interface",
            "level": 2,
            "evaluatorReader": false,
            "collapsed": true
        },
        {
            "id": "markdowncFVLHO",
            "type": "markdown",
            "body": [
                "`java.util.Runnable` interface has method `run()`",
                "```Java",
                "public interface Runnable",
                "{",
                "  void run();",
                "}",
                "```"
            ],
            "evaluatorReader": false
        },
        {
            "id": "codeDJph1Z",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "public class BankAccount",
                    "{",
                    "  private double amount = 0.00;",
                    "  ",
                    "  public void deposit(double money)",
                    "  {",
                    "    amount += money;",
                    "  }",
                    "  ",
                    "  public double getAmount() ",
                    "  {",
                    "    return amount;",
                    "  }",
                    "}"
                ]
            },
            "output": {
                "state": {},
                "selectedType": "Text",
                "pluginName": "Java",
                "shellId": "25b074cf-4c88-4929-bae0-cda09287715d",
                "height": 36
            },
            "evaluatorReader": true,
            "lineCount": 14
        },
        {
            "id": "section1sLhwh",
            "type": "section",
            "title": "Step 1: Write your task into `run()` method",
            "level": 2,
            "evaluatorReader": false,
            "collapsed": true
        },
        {
            "id": "codeiI9DuV",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "public class MyRunnableTask implements Runnable",
                    "{",
                    "  private double money;",
                    "  private BankAccount account;",
                    "  ",
                    "  public MyRunnableTask(BankAccount account, double money)",
                    "  {",
                    "    this.account = account;",
                    "    this.money = money;",
                    "  }",
                    "  ",
                    "  @Override",
                    "  public void run()",
                    "  {",
                    "    account.deposit(money);",
                    "  }",
                    "}"
                ]
            },
            "output": {
                "state": {},
                "selectedType": "Text",
                "pluginName": "Java",
                "shellId": "25b074cf-4c88-4929-bae0-cda09287715d",
                "height": 36
            },
            "evaluatorReader": true,
            "lineCount": 17
        },
        {
            "id": "sectionU3pAET",
            "type": "section",
            "title": "Step 3: Create an object of your task",
            "level": 2,
            "evaluatorReader": false,
            "collapsed": true
        },
        {
            "id": "markdownan4GZU",
            "type": "markdown",
            "body": [
                "```Java",
                "Runnable r = new MyRunnableTask(\"Hello Thread\");",
                "```"
            ],
            "evaluatorReader": false
        },
        {
            "id": "sectionMiSFbg",
            "type": "section",
            "title": "Step 4: Construct a `Thread` object from the runnable object",
            "level": 2,
            "evaluatorReader": false,
            "collapsed": true
        },
        {
            "id": "markdownumA9qt",
            "type": "markdown",
            "body": [
                "```Java",
                "Thread t = new Thread(r);",
                "```"
            ],
            "evaluatorReader": false
        },
        {
            "id": "sectionMFneo6",
            "type": "section",
            "title": "Step 5: Call the `start()` method to start the thread",
            "level": 2,
            "evaluatorReader": false,
            "collapsed": true
        },
        {
            "id": "markdownFivwG4",
            "type": "markdown",
            "body": [
                "```Java",
                "t.start();",
                "```"
            ],
            "evaluatorReader": false
        },
        {
            "id": "sectionIyVc78",
            "type": "section",
            "title": "Hello Thread",
            "level": 2,
            "evaluatorReader": false,
            "collapsed": true
        },
        {
            "id": "code4VG7pd",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "BankAccount myAccount = new BankAccount();",
                    "Runnable r = new MyRunnableTask(myAccount, 1);",
                    "Thread t = new Thread(r);",
                    "t.start();",
                    "",
                    "// wait until thread is finish",
                    "while (true) {",
                    "  if (!t.isAlive()) {",
                    "    break;",
                    "  }",
                    "  java.util.concurrent.TimeUnit.SECONDS.sleep(1);",
                    "}",
                    "System.out.println(myAccount.getAmount());"
                ]
            },
            "output": {
                "state": {},
                "selectedType": "Results",
                "pluginName": "Java",
                "shellId": "25b074cf-4c88-4929-bae0-cda09287715d"
            },
            "evaluatorReader": true,
            "lineCount": 13
        },
        {
            "id": "sectionrnxMJI",
            "type": "section",
            "title": "`Thread.sleep(milliseconds)`",
            "level": 2,
            "evaluatorReader": false,
            "collapsed": true
        },
        {
            "id": "markdownIZ6ja7",
            "type": "markdown",
            "body": [
                "The `sleep()` method puts the current thread to sleep for a given number of milliseconds",
                "",
                "* A thread might sleep for so long that it is no longer useful and should be ternimated.",
                "* When a sleeping thread is interrupted, an `InterruptedException` is generated.",
                "* You need to catch that exception in your `run()` method and terminate the thread.",
                "",
                "```Java",
                "public void run()",
                "{",
                "  try",
                "  {",
                "    // Task statements",
                "    Thread.sleep(1000); // sleep for 1 second",
                "  } catch(InterruptedException exception) {",
                "    // ...",
                "  }",
                "  // Clean up, if neccesary.",
                "}",
                "```"
            ],
            "evaluatorReader": false
        },
        {
            "id": "codeHJW4CV",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "public class BankAccountRunnableTask implements Runnable",
                    "{",
                    "  private final int REPETITIONS = 10;",
                    "  private final int DELAY = 1000;",
                    "  private double money;",
                    "  private BankAccount account;",
                    "  ",
                    "  public BankAccountRunnableTask(BankAccount account, double money)",
                    "  {",
                    "    this.account = account;",
                    "    this.money = money;",
                    "  }",
                    "  ",
                    "  @Override",
                    "  public void run()",
                    "  {",
                    "    try {",
                    "      for (int i = 1; i <= REPETITIONS; i++) {",
                    "        account.deposit(money);",
                    "        Thread.sleep(DELAY); // sleep thread for 1 second",
                    "      }",
                    "    } catch (InterruptedException exception) {",
                    "      System.err.println(\"Thread was interrupted\");",
                    "    }",
                    "  }",
                    "}"
                ]
            },
            "output": {
                "state": {},
                "selectedType": "Text",
                "pluginName": "Java",
                "shellId": "25b074cf-4c88-4929-bae0-cda09287715d",
                "height": 36
            },
            "evaluatorReader": true,
            "lineCount": 26
        },
        {
            "id": "codeprYyUI",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "BankAccount myAccount = new BankAccount();",
                    "Runnable r = new BankAccountRunnableTask(myAccount, 1);",
                    "Thread t = new Thread(r);",
                    "t.start();",
                    "",
                    "while (true) {",
                    "  if (!t.isAlive()) {",
                    "    break;",
                    "  }",
                    "  System.out.println(\"(DEBUG) amount: \" + myAccount.getAmount());",
                    "  java.util.concurrent.TimeUnit.SECONDS.sleep(1);",
                    "}",
                    "System.out.println(myAccount.getAmount());"
                ]
            },
            "output": {
                "state": {},
                "selectedType": "Results",
                "pluginName": "Java",
                "shellId": "25b074cf-4c88-4929-bae0-cda09287715d"
            },
            "evaluatorReader": true,
            "lineCount": 13
        },
        {
            "id": "sectionVVMn0Y",
            "type": "section",
            "title": "Multithreading",
            "level": 2,
            "evaluatorReader": false,
            "collapsed": true
        },
        {
            "id": "sectionmWdjZE",
            "type": "section",
            "title": "Multithreading on each account",
            "level": 3,
            "evaluatorReader": false,
            "collapsed": true
        },
        {
            "id": "codeefWPnw",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "BankAccount[] accounts = new BankAccount[3];",
                    "Thread[] threads = new Thread[3];",
                    "",
                    "for (int i=0; i<threads.length; i++) {",
                    "  accounts[i] = new BankAccount();",
                    "  threads[i] = new Thread(new BankAccountRunnableTask(accounts[i], Math.pow(10, (2 * i))));",
                    "}",
                    "",
                    "for (Thread t : threads) {",
                    "  t.start();  ",
                    "}",
                    "",
                    "// check whether all threads are finish ====================================================",
                    "int[] finishThreads = new int[]{0, 0, 0};",
                    "while (true) {",
                    "  for (int i=0; i<threads.length; i++) {",
                    "    if ((finishThreads[i] == 0) && !threads[i].isAlive()) {",
                    "      finishThreads[i] = 1;",
                    "    }",
                    "    System.out.println(\"(DEBUG) amount in account \" + i + \" : \" + accounts[i].getAmount());",
                    "  }",
                    "  java.util.concurrent.TimeUnit.SECONDS.sleep(1);",
                    "  int sum = java.util.stream.IntStream.of(finishThreads).sum();",
                    "  if (sum == threads.length) break;",
                    "}",
                    "",
                    "for (int i=0; i<accounts.length; i++)",
                    "  System.out.println(\"Amount in account \" + i + \" : \" + accounts[i].getAmount());"
                ]
            },
            "output": {
                "state": {},
                "selectedType": "Results",
                "pluginName": "Java",
                "shellId": "25b074cf-4c88-4929-bae0-cda09287715d"
            },
            "evaluatorReader": true,
            "lineCount": 28
        },
        {
            "id": "sectionQtKhZQ",
            "type": "section",
            "title": "Multithreading on same account",
            "level": 3,
            "evaluatorReader": false,
            "collapsed": true
        },
        {
            "id": "codeT90o7X",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "BankAccount myAccount = new BankAccount();",
                    "",
                    "Thread[] threads = new Thread[3];",
                    "threads[0] = new Thread(new BankAccountRunnableTask(myAccount, 1));",
                    "threads[1] = new Thread(new BankAccountRunnableTask(myAccount, 100));",
                    "threads[2] = new Thread(new BankAccountRunnableTask(myAccount, 10000));",
                    "for (Thread t : threads) {",
                    "  t.start();  ",
                    "}",
                    "",
                    "// check whether all threads are finish ====================================================",
                    "int[] finishThreads = new int[]{0, 0, 0};",
                    "while (true) {",
                    "  for (int i=0; i<threads.length; i++) {",
                    "    if ((finishThreads[i] == 0) && !threads[i].isAlive()) {",
                    "      finishThreads[i] = 1;",
                    "    }",
                    "    System.out.println(\"(DEBUG) amount on thread \" + i + \" : \" + myAccount.getAmount());",
                    "  }",
                    "  java.util.concurrent.TimeUnit.SECONDS.sleep(1);",
                    "  int sum = java.util.stream.IntStream.of(finishThreads).sum();",
                    "  if (sum == threads.length) break;",
                    "}",
                    "",
                    "System.out.println(myAccount.getAmount());"
                ]
            },
            "output": {
                "state": {},
                "selectedType": "Results",
                "pluginName": "Java",
                "shellId": "25b074cf-4c88-4929-bae0-cda09287715d"
            },
            "evaluatorReader": true,
            "lineCount": 25
        },
        {
            "id": "sectionkVNlr0",
            "type": "section",
            "title": "Thread Pools with `ExecutorService`",
            "level": 2,
            "evaluatorReader": false,
            "collapsed": true
        },
        {
            "id": "markdown5Tlndp",
            "type": "markdown",
            "body": [
                "* Threads are managed by the operating system, and there is a cost for creating threads.",
                "* Each thread requires memory, and thread creation takes time.",
                "* This cost can be reduced by using a thread pool."
            ],
            "evaluatorReader": false
        },
        {
            "id": "codeE9Zlff",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "import java.util.concurrent.ExecutorService;",
                    "import java.util.concurrent.Executors;",
                    "import java.util.concurrent.TimeUnit;",
                    "",
                    "BankAccount myAccount = new BankAccount(); // try debugging amount in eclipse",
                    "",
                    "int MAX_THREADS = 2; // กำหนดจำนวนสูงสุดของ threads ใน pool (หมายความว่าจะ run พร้อมกัน รอบละ 2 threads)",
                    "// กำหนด thread pool",
                    "ExecutorService pool = Executors.newFixedThreadPool(MAX_THREADS);",
                    "",
                    "Runnable[] r = new Runnable[4];",
                    "",
                    "for (int i=0; i<r.length; i++) {",
                    "  r[i] = new BankAccountRunnableTask(myAccount, Math.pow(10, 2*i));",
                    "  pool.execute(r[i]);",
                    "}",
                    "",
                    "pool.shutdown(); ",
                    "",
                    "System.out.println(myAccount.getAmount());",
                    "try {",
                    "  if(pool.awaitTermination(1, TimeUnit.MINUTES)) {",
                    "    System.out.println(myAccount.getAmount());",
                    "  }",
                    "} catch (InterruptedException e) {",
                    "  e.printStackTrace();",
                    "}"
                ]
            },
            "output": {
                "state": {},
                "selectedType": "Results",
                "pluginName": "Java",
                "shellId": "25b074cf-4c88-4929-bae0-cda09287715d"
            },
            "evaluatorReader": true,
            "lineCount": 27
        },
        {
            "id": "sectionBRvf2t",
            "type": "section",
            "title": "Terminating Threads",
            "level": 1,
            "evaluatorReader": false,
            "collapsed": true
        },
        {
            "id": "markdown6pHZ4J",
            "type": "markdown",
            "body": [
                "## 1. The normal way of terminating a thread",
                "* When the `run()` method of a thread has finished executing.",
                "",
                "## 2. `interrupt()` method",
                "* You may have several threads trying to find a solution to a problem.",
                "* As soon as the first one has succeeded, you may want to terminate the other ones.",
                "* To notify a thread that it should clean up and terminate, you use the `interrupt()` method.",
                "",
                ""
            ],
            "evaluatorReader": false
        },
        {
            "id": "sectionqurvqr",
            "type": "section",
            "title": "`GuessNumber`",
            "level": 2,
            "evaluatorReader": false,
            "collapsed": true
        },
        {
            "id": "codeeHccNM",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "public class GuessNumber {",
                    "  private int target;",
                    "  ",
                    "  public GuessNumber(int target) {",
                    "    this.target = target;",
                    "  }",
                    "  ",
                    "  public boolean guess(int number) {",
                    "      return target == number;",
                    "  }",
                    "}"
                ]
            },
            "output": {
                "state": {},
                "selectedType": "Text",
                "pluginName": "Java",
                "shellId": "bee5f161-4d00-4248-9de2-8e2d371fbf96"
            },
            "evaluatorReader": true,
            "lineCount": 11
        },
        {
            "id": "section3mwfuv",
            "type": "section",
            "title": "`GuessNumberListener`",
            "level": 2,
            "evaluatorReader": false,
            "collapsed": true
        },
        {
            "id": "codeIXee7X",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "public class GuessNumberListener {",
                    "  private boolean stopThreads = false;",
                    "  ",
                    "  public void setStopSignal() {",
                    "    stopThreads = true;",
                    "  }",
                    "  ",
                    "  public boolean getStopThread() {",
                    "    return stopThreads;",
                    "  }",
                    "}"
                ]
            },
            "output": {
                "state": {},
                "selectedType": "Text",
                "pluginName": "Java",
                "shellId": "25b074cf-4c88-4929-bae0-cda09287715d"
            },
            "evaluatorReader": true,
            "lineCount": 11
        },
        {
            "id": "section75V3de",
            "type": "section",
            "title": "`GuessRunnableTask`",
            "level": 2,
            "evaluatorReader": false,
            "collapsed": true
        },
        {
            "id": "codeXPy19u",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "public class GuessRunnableTask implements Runnable {",
                    "  private GuessNumber guessNumber;",
                    "  private GuessNumberListener listener;",
                    "  private int start;",
                    "  private int end;",
                    "  private int countGuess;",
                    "  private boolean found;",
                    "  ",
                    "  public GuessRunnableTask(GuessNumber guessNumber, int start, int end, GuessNumberListener listener) {",
                    "    this.guessNumber = guessNumber;",
                    "    this.start = start;",
                    "    this.end = end;",
                    "    this.listener = listener;",
                    "  }",
                    "  ",
                    "  @Override",
                    "  public void run() {",
                    "    try {",
                    "      for (int i=start; i<=end; i++) {",
                    "        countGuess++;",
                    "        if (guessNumber.guess(i)) {",
                    "          found = true;",
                    "          listener.setStopSignal();",
                    "          break;",
                    "        }",
                    "         Thread.sleep(200);",
                    "      }",
                    "    } catch (InterruptedException exception) {",
                    "      ",
                    "    }",
                    "  }",
                    "  ",
                    "  public boolean getFound() {",
                    "    return found;",
                    "  }",
                    "  ",
                    "  public int getCountGuess() {",
                    "    return countGuess;",
                    "  }",
                    "}"
                ]
            },
            "output": {
                "state": {},
                "selectedType": "Text",
                "pluginName": "Java",
                "shellId": "25b074cf-4c88-4929-bae0-cda09287715d"
            },
            "evaluatorReader": true,
            "lineCount": 40
        },
        {
            "id": "sectionEeOYBb",
            "type": "section",
            "title": "Guess Number with Multithreading",
            "level": 2,
            "evaluatorReader": false,
            "collapsed": true
        },
        {
            "id": "coderD8c1O",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "  GuessNumber puzzle = new GuessNumber(56);",
                    "GuessNumberListener stopThreadsListener = new GuessNumberListener();",
                    "",
                    "GuessRunnableTask[] r = new GuessRunnableTask[4];",
                    "Thread[] threads = new Thread[4];",
                    "",
                    "for (int i=0; i<threads.length; i++) {",
                    "  r[i] = new GuessRunnableTask(puzzle, 50 * i + 1, 50 * (i + 1), stopThreadsListener);",
                    "  threads[i] = new Thread(r[i]);",
                    "}",
                    "",
                    "for (Thread t : threads) {",
                    "  t.start();  ",
                    "}",
                    "",
                    "// check whether all threads are finish ====================================================",
                    "int[] finishThreads = new int[]{0, 0, 0, 0};",
                    "while (true) {",
                    "  if (stopThreadsListener.getStopThread()) {",
                    "    for (Thread t : threads) {",
                    "      // To notify a thread that it should clean up and terminate, you use the interrupt() method.",
                    "      t.interrupt();  ",
                    "    }",
                    "  }",
                    "  ",
                    "  for (int i=0; i<threads.length; i++) {",
                    "    if ((finishThreads[i] == 0) && !threads[i].isAlive()) {",
                    "      finishThreads[i] = 1;",
                    "    }",
                    "    ",
                    "  }",
                    "  ",
                    "  int sum = java.util.stream.IntStream.of(finishThreads).sum();",
                    "  if (sum == threads.length) break;",
                    "  java.util.concurrent.TimeUnit.SECONDS.sleep(1);",
                    "}",
                    "",
                    "for (int i=0; i<r.length; i++)",
                    "  System.out.println(\"Task \" + i + \" {found:\" + r[i].getFound() + \", count:\" + r[i].getCountGuess() + \"}\");"
                ]
            },
            "output": {
                "state": {},
                "selectedType": "Results",
                "pluginName": "Java",
                "shellId": "25b074cf-4c88-4929-bae0-cda09287715d"
            },
            "evaluatorReader": true,
            "lineCount": 39
        },
        {
            "id": "sectionl6Knpc",
            "type": "section",
            "title": "Race Conditions",
            "level": 1,
            "evaluatorReader": false,
            "collapsed": true
        },
        {
            "id": "markdownfHqVDI",
            "type": "markdown",
            "body": [
                "When threads share access to a common object, they can conflict with each other."
            ],
            "evaluatorReader": false
        },
        {
            "id": "sectionFIYrel",
            "type": "section",
            "title": "`BankAccount`",
            "level": 2,
            "evaluatorReader": false,
            "collapsed": true
        },
        {
            "id": "codejfqR8G",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "public class BankAccount {",
                    "    private double balance = 0;",
                    "",
                    "    public void deposit(double amount) {",
                    "        balance += amount;",
                    "    }",
                    "",
                    "    public void withdraw(double amount) {",
                    "        balance -= amount;",
                    "    }",
                    "",
                    "    public double getBalance() {",
                    "        return balance;",
                    "    }",
                    "}"
                ]
            },
            "output": {
                "state": {},
                "selectedType": "Text",
                "pluginName": "Java",
                "shellId": "bee5f161-4d00-4248-9de2-8e2d371fbf96",
                "height": 35
            },
            "evaluatorReader": true,
            "lineCount": 15
        },
        {
            "id": "sectionVbfg6l",
            "type": "section",
            "title": "`DepositRunnableTask`",
            "level": 2,
            "evaluatorReader": false,
            "collapsed": true
        },
        {
            "id": "codewU2l3O",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "public class DepositRunnableTask implements Runnable {",
                    "    private BankAccount account;",
                    "    private double amount;",
                    "    private int repetitions;",
                    "    private boolean finish = false;",
                    "",
                    "    public DepositRunnableTask(BankAccount account, double amount, int repetitions) {",
                    "        this.account = account;",
                    "        this.amount = amount;",
                    "        this.repetitions = repetitions;",
                    "    }",
                    "",
                    "    @Override",
                    "    public void run() {",
                    "        for (int i = 0; i < repetitions; i++) {",
                    "            account.deposit(amount);",
                    "        }",
                    "        finish = true;",
                    "    }",
                    "",
                    "    public boolean isFinish() {",
                    "        return finish;",
                    "    }",
                    "}"
                ]
            },
            "output": {
                "state": {},
                "selectedType": "Text",
                "pluginName": "Java",
                "shellId": "bee5f161-4d00-4248-9de2-8e2d371fbf96"
            },
            "evaluatorReader": true,
            "lineCount": 24
        },
        {
            "id": "sectionPlglBm",
            "type": "section",
            "title": "`WithdrawRunnableTask`",
            "level": 2,
            "evaluatorReader": false,
            "collapsed": true
        },
        {
            "id": "codef4C7qw",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "public class WithdrawRunnableTask implements Runnable {",
                    "    private BankAccount account;",
                    "    private double amount;",
                    "    private int repetitions;",
                    "    private boolean finish = false;",
                    "",
                    "    public WithdrawRunnableTask(BankAccount account, double amount, int repetitions) {",
                    "        this.account = account;",
                    "        this.amount = amount;",
                    "        this.repetitions = repetitions;",
                    "    }",
                    "",
                    "    @Override",
                    "    public void run() {",
                    "        for (int i = 0; i < repetitions; i++) {",
                    "            account.withdraw(amount);",
                    "        }",
                    "        finish = true;",
                    "    }",
                    "",
                    "    public boolean isFinish() {",
                    "        return finish;",
                    "    }",
                    "}"
                ]
            },
            "output": {
                "state": {},
                "selectedType": "Text",
                "pluginName": "Java",
                "shellId": "bee5f161-4d00-4248-9de2-8e2d371fbf96"
            },
            "evaluatorReader": true,
            "lineCount": 24
        },
        {
            "id": "sectionvBdF3h",
            "type": "section",
            "title": "BankAccount Race Conditions",
            "level": 2,
            "evaluatorReader": false,
            "collapsed": true
        },
        {
            "id": "markdownEtjrUR",
            "type": "markdown",
            "body": [
                "Balance should be 0"
            ],
            "evaluatorReader": false
        },
        {
            "id": "codeQJE5MP",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "BankAccount account = new BankAccount();",
                    "final double AMOUNT = 100;",
                    "final int REPETITIONS = 100;",
                    "final int THREADS = 100;",
                    "",
                    "DepositRunnableTask[] ds = new DepositRunnableTask[THREADS];",
                    "WithdrawRunnableTask[] ws = new WithdrawRunnableTask[THREADS];",
                    "",
                    "for (int i = 0; i < THREADS; i++) {",
                    "  ds[i] = new DepositRunnableTask(account, AMOUNT, REPETITIONS);",
                    "  ws[i] = new WithdrawRunnableTask(account, AMOUNT, REPETITIONS);",
                    "  (new Thread(ds[i])).start();",
                    "  (new Thread(ws[i])).start();",
                    "}",
                    "",
                    "int[] finishDs = new int[THREADS];",
                    "int[] finishWs = new int[THREADS];",
                    "",
                    "while (true) {",
                    "  for (int i = 0; i<THREADS; i++) {",
                    "    if (ds[i].isFinish()) finishDs[i] = 1;",
                    "    if (ws[i].isFinish()) finishWs[i] = 1;",
                    "  }",
                    "  int sum = java.util.stream.IntStream.of(finishDs).sum();",
                    "  sum += java.util.stream.IntStream.of(finishWs).sum();",
                    "  if (sum == 2 * THREADS) ",
                    "    break;",
                    "}",
                    "System.out.println(account.getBalance());"
                ]
            },
            "output": {
                "state": {},
                "selectedType": "Results",
                "pluginName": "Java",
                "shellId": "bee5f161-4d00-4248-9de2-8e2d371fbf96"
            },
            "evaluatorReader": true,
            "lineCount": 29
        },
        {
            "id": "sectionSeJbet",
            "type": "section",
            "title": "Synchronizing Object Access",
            "level": 1,
            "evaluatorReader": false,
            "collapsed": true
        },
        {
            "id": "section12nvYb",
            "type": "section",
            "title": "Lock object",
            "level": 2,
            "evaluatorReader": false,
            "collapsed": true
        },
        {
            "id": "markdownyOeCxZ",
            "type": "markdown",
            "body": [
                "* The lock object is used to control the threads that want to manipulate a shared resource.",
                "* The Java library defines a `Lock` interface and several classes that implement this interface.",
                "* The `ReentranLock` class is the most commonly used lock class.",
                "",
                "```Java",
                "pulbic class BankAccount",
                "{",
                "  private Lock balanceChangeLock;",
                "  . . .",
                "  public BankAccount()",
                "  {",
                "    balanceChangeLock = new ReentrantLock();",
                "    . . .",
                "  }",
                "}",
                "```"
            ],
            "evaluatorReader": false
        },
        {
            "id": "markdowndVGMqj",
            "type": "markdown",
            "body": [
                "* All code that manipulates the shared resource is surrounded by calls to lock and unlock the lock object",
                "",
                "```Java",
                "    balanceChangeLock.lock();",
                "    // Manipulate the shared resource.",
                "    balanceChangeLock.unlock();",
                "```"
            ],
            "evaluatorReader": false
        },
        {
            "id": "markdownkfA2cA",
            "type": "markdown",
            "body": [
                "* However, this sequence of statements has a potential flaw.",
                "* If the code between the calls to `lock()` and `unlock()` throws an exception, the call to `unlock()` never happens.",
                "* To overcome this problem, place the call to `unlock()` into a `finally` clause.",
                "",
                "```Java",
                "    balanceChangeLock.lock();",
                "    try {",
                "        // Manipulate the shared resource.",
                "    } finally {",
                "        balanceChangeLock.unlock();",
                "    }",
                "```"
            ],
            "evaluatorReader": false
        },
        {
            "id": "markdownIGLDdl",
            "type": "markdown",
            "body": [
                "* When a thread calls the `lock()` method, it _owns the lock_ until its calls the `unlock()` method.",
                "* If a thread calls `lock()` while another thread owns the lock, the first thread is temporarily deactivated.",
                "* Eventually, when the lock is available because the original thread unlocked it, the waiting thread can acquire the lock."
            ],
            "evaluatorReader": false
        },
        {
            "id": "section2K5BBR",
            "type": "section",
            "title": "`BankAccount` using `Lock`",
            "level": 2,
            "evaluatorReader": false,
            "collapsed": true
        },
        {
            "id": "codeHK8pR7",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "import java.util.concurrent.locks.Lock;",
                    "import java.util.concurrent.locks.ReentrantLock;",
                    "",
                    "public class BankAccount {",
                    "    private double balance = 0;",
                    "    private Lock balanceChangeLock = new ReentrantLock();",
                    "",
                    "    public void deposit(double amount) {",
                    "        balanceChangeLock.lock();",
                    "        try {",
                    "            balance += amount;",
                    "        } finally {",
                    "            balanceChangeLock.unlock();",
                    "        }",
                    "    }",
                    "",
                    "    public void withdraw(double amount) {",
                    "        balanceChangeLock.lock();",
                    "        try {",
                    "            balance -= amount;",
                    "        } finally {",
                    "            balanceChangeLock.unlock();",
                    "        }",
                    "    }",
                    "",
                    "    public double getBalance() {",
                    "        return balance;",
                    "    }",
                    "",
                    "}"
                ]
            },
            "output": {
                "state": {},
                "selectedType": "Text",
                "pluginName": "Java",
                "shellId": "bee5f161-4d00-4248-9de2-8e2d371fbf96"
            },
            "evaluatorReader": true,
            "lineCount": 30
        },
        {
            "id": "sectionIsfYxi",
            "type": "section",
            "title": "BankAccount Race Conditions with Lock",
            "level": 2,
            "evaluatorReader": false,
            "collapsed": true
        },
        {
            "id": "codeKGVi2a",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "BankAccount account = new BankAccount();",
                    "final double AMOUNT = 100;",
                    "final int REPETITIONS = 100;",
                    "final int THREADS = 100;",
                    "",
                    "DepositRunnableTask[] ds = new DepositRunnableTask[THREADS];",
                    "WithdrawRunnableTask[] ws = new WithdrawRunnableTask[THREADS];",
                    "",
                    "for (int i = 0; i < THREADS; i++) {",
                    "  ds[i] = new DepositRunnableTask(account, AMOUNT, REPETITIONS);",
                    "  ws[i] = new WithdrawRunnableTask(account, AMOUNT, REPETITIONS);",
                    "  (new Thread(ds[i])).start();",
                    "  (new Thread(ws[i])).start();",
                    "}",
                    "",
                    "int[] finishDs = new int[THREADS];",
                    "int[] finishWs = new int[THREADS];",
                    "",
                    "while (true) {",
                    "  for (int i = 0; i<THREADS; i++) {",
                    "    if (ds[i].isFinish()) finishDs[i] = 1;",
                    "    if (ws[i].isFinish()) finishWs[i] = 1;",
                    "  }",
                    "  int sum = java.util.stream.IntStream.of(finishDs).sum();",
                    "  sum += java.util.stream.IntStream.of(finishWs).sum();",
                    "  if (sum == 2 * THREADS) ",
                    "    break;",
                    "}",
                    "System.out.println(account.getBalance());"
                ]
            },
            "output": {
                "state": {},
                "selectedType": "Results",
                "pluginName": "Java",
                "shellId": "bee5f161-4d00-4248-9de2-8e2d371fbf96"
            },
            "evaluatorReader": true,
            "lineCount": 29
        },
        {
            "id": "sectionS2ZAOP",
            "type": "section",
            "title": "Avoiding DeadLocks",
            "level": 1,
            "evaluatorReader": false,
            "collapsed": true
        },
        {
            "id": "markdownRKkwQg",
            "type": "markdown",
            "body": [
                "* You can use lock objects to ensure that shared data are in a consistent state when several threads access them.",
                "* However, locks can lead to another problem.",
                "",
                ""
            ],
            "evaluatorReader": false
        },
        {
            "id": "sectionJtC3iM",
            "type": "section",
            "title": "Deadlock",
            "level": 2,
            "evaluatorReader": false,
            "collapsed": true
        },
        {
            "id": "markdownmeVyGk",
            "type": "markdown",
            "body": [
                "* One thread acquires a lock and then waits for another thread to do some essential work.",
                "* If that other thread is currently waiting to acquire the same lock, neither of the two threads can proceed."
            ],
            "evaluatorReader": false
        },
        {
            "id": "codefnQAdo",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "public void withdraw(double amount) ",
                    "{",
                    "  balanceChangeLock.lock();",
                    "  try {",
                    "    while (balance < amount) {",
                    "      // Wait for the balance to grow.",
                    "    }",
                    "    . . .",
                    "  } finally {",
                    "    balanceChangeLock.unlock();",
                    "  }",
                    "}"
                ]
            },
            "output": {
                "state": {}
            },
            "evaluatorReader": true,
            "lineCount": 12
        },
        {
            "id": "sectionCeN2Sp",
            "type": "section",
            "title": "Condition Object",
            "level": 2,
            "evaluatorReader": false,
            "collapsed": true
        },
        {
            "id": "markdownNHAFPl",
            "type": "markdown",
            "body": [
                "* To overcome this problem, we use a **condition object**.",
                "* Condition objects allow a thread to temporarily release a lock.",
                "* Each condition object belongs to a specific lock object."
            ],
            "evaluatorReader": false
        },
        {
            "id": "sectionsFaoLd",
            "type": "section",
            "title": "`BankAccount` using Condition Object",
            "level": 2,
            "evaluatorReader": false,
            "collapsed": true
        },
        {
            "id": "markdownVlT4gs",
            "type": "markdown",
            "body": [
                "* You obtain a condition object with the `newCondition()` method of the `Lock` interface.",
                "* Calling `await()` on a condition object makes the current thread wait and allows another thread to acquire the lock object.",
                "* To unblock, another thread must execute the `signalAll()` method _on the same condition object_."
            ],
            "evaluatorReader": false
        },
        {
            "id": "codeOcK9h6",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "import java.util.concurrent.locks.Condition;",
                    "import java.util.concurrent.locks.Lock;",
                    "import java.util.concurrent.locks.ReentrantLock;",
                    "",
                    "public class BankAccount {",
                    "    private double balance = 0;",
                    "    private Lock balanceChangeLock;",
                    "    private Condition sufficientFundsCondition;",
                    "",
                    "    public BankAccount() {",
                    "        balanceChangeLock = new ReentrantLock();",
                    "        // You obtain a condition object with the newCondition() method of the Lock interface.",
                    "        sufficientFundsCondition = balanceChangeLock.newCondition();",
                    "    }",
                    "",
                    "    public void deposit(double amount) {",
                    "        balanceChangeLock.lock();",
                    "        try {",
                    "            balance += amount;",
                    "            // To unblock, another thread must execute the signalAll() method on the same condition object.",
                    "            sufficientFundsCondition.signalAll();",
                    "        } finally {",
                    "            balanceChangeLock.unlock();",
                    "        }",
                    "    }",
                    "",
                    "    public void withdraw(double amount) {",
                    "        balanceChangeLock.lock();",
                    "        try {",
                    "            // Calling await() on a condition object makes the current thread wait ",
                    "            // and allows another thread to acquire the lock object",
                    "            while (balance < amount) ",
                    "                sufficientFundsCondition.await();",
                    "            balance -= amount;",
                    "        } catch (InterruptedException e) {",
                    "            e.printStackTrace();",
                    "        } finally {",
                    "            balanceChangeLock.unlock();",
                    "        }",
                    "    }",
                    "",
                    "    public double getBalance() {",
                    "        return balance;",
                    "    }",
                    "",
                    "}"
                ]
            },
            "output": {
                "state": {}
            },
            "evaluatorReader": true,
            "lineCount": 46
        },
        {
            "id": "sectionwU0Irp",
            "type": "section",
            "title": "Common Error",
            "level": 2,
            "evaluatorReader": false,
            "collapsed": true
        },
        {
            "id": "markdownHkct8F",
            "type": "markdown",
            "body": [
                "## 1. Calling `await()` without calling `signalAll()`."
            ],
            "evaluatorReader": false
        },
        {
            "id": "markdown8BkZO7",
            "type": "markdown",
            "body": [
                "## 2. Calling `signalAll()` without locking the object."
            ],
            "evaluatorReader": false
        }
    ],
    "namespace": {}
}
